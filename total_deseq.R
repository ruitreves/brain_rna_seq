library(DESeq2)
#we use this, which is generated by STAR, to add gene names 
genes <- read.table("geneInfo.tab", header = TRUE, col.names = c("ENS", "gene", "function"))
#remove function column
gene_names <- genes[, -3]
#column fix
gene_names <- cf(gene_names)

#function for running DESeq on all the groupwise comparisons 
make_de <- function(my_data, p = 0.05, f = 1, smallest_group_size = 1) {
    counter <- 1
    for (i in 1:length(my_data)) {
        counter = counter + 1
        if (counter <= length(my_data)) {
            for (j in counter:length(my_data)) {
                #this combo of for loops, if statement and counter variable is how we achieve the proper
                #groupwise comparisons without repeats.
                #get data we want to analyze
                d <- merge(my_data[[i]], my_data[[j]], by = 0)
                d <- cf(d)
                #now we build dds and metadata, using gsub to remove sample number and leave only group prefix
                metadata <- data.frame(samples = colnames(d), condition = gsub("_.*", "", colnames(d)))
                
                dds <- DESeqDataSetFromMatrix(countData = d, colData = metadata, design = ~ condition)
                #filter out low counts, we require at least smallest_group_size number of samples to have more
                #than 10 counts per row (per gene)
                keep <- rowSums(counts(dds) > 10) >= smallest_group_size
                dds <- dds[keep, ]
                #run DESeq
                dds <- DESeq(dds)
                #Get results
                res <- results(dds)
                #check
                print(res)
                #this step is necessary in order to merge with our gene names
                res <- as.data.frame(res)
                #get current conditions from metadata
                conds <- unique(metadata$condition)
                #write.csv res
                write.csv(res, paste0(conds[1], "_vs_", conds[2], "_extended_info.csv"))
                #get significant DEGS based on specified p and f values
                sig <- res[complete.cases(res), ]
                sig <- sig[sig$padj < p, ]
                sig <- sig[abs(sig$log2FoldChange) > f, ]
                #check
                print(head(sig))
                write.csv(sig, paste0(conds[1], "_vs_", conds[2], "_SIG_DEGS_extended_info.csv"))
                #get the normalized counts
                nc <- counts(dds, normalized = TRUE)
                #well merge gene names with nc, and then nc with res and sig
                nc <- merge(nc, gene_names, by = 0)
                nc <- cf(nc)
                print(head(nc))
                write.csv(nc, paste0(conds[1], "_vs_", conds[2], "_normalized_counts.csv"))
                #this is combining logFC, pval, padj with normalized counts for all genes
                deg_results <- res[, c(2, 5, 6)]
                deg_results <- merge(deg_results, nc, by = 0)
                deg_results <- cf(deg_results)
                print(head(deg_results))
                write.csv(deg_results, paste0(conds[1], "_vs_", conds[2], "_DEG_results.csv"))
                #this is combining logFC, pval, padj with normalized counts for sig DEGS 
                sig_degs <- sig[, c(2, 5, 6)]
                sig_degs <- merge(sig_degs, nc, by = 0)
                sig_degs <- cf(sig_degs)
                print(head(sig_degs))
                write.csv(sig_degs, paste0(conds[1], "_vs_", conds[2], "_Significant_DEGS.csv"))

                #nothing to return, this just writes csv files
            }
        }
    }
}
#function call, using default p and f. 
make_de(res, smallest_group_size = 4)
